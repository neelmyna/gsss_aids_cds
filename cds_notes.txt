Create Github Account using permanent email and phone number

Create New Repo
Click on + (top right) in logged in page
Click New Repository (Drop down list)
Name of Repo: mtd_cds
Keep the Repo public
Select the check box add readme file
Click the green button create repo

https://github.com/neelmyna/gsss_aids_cds

Configuration:

git config --global user.name "neelmyna"
git config --global user.email "MY_EMAIL"
Credential Manager (Windows)

Create Personal Access Token (PAT)
Click on top right profile icon
Click Settings (Down in the list)
Next page, scroll down and click developer settings
Nex page, on top left, Click tokens classic
Next page, Click generate new token, select classic
Expiration: Select No Expiry
Note: for all my learning during my engg
Scope: Select the very 1st checkbox Repo
Scroll down and Click generate new token (green button)
PAT is created and Copy button (Copy it)
Mail the PAT to yourself (mail subject git_pat)

SRP

float num = 4.75;


gcc steps:
1. pre processing (includes/opens/loads the mentioned files)
2. Compilation
	1. Syntax checking
	2. Translation (HR code to MR code)
	3. Interpretation (O/P is object code)
3. Linking (O/P: executable file)

gcc Options:
-E  To stop after pre-processing
O/P: User defined code + Library code
-c  To stop after compilation (object code is generated)
-o  To specify the target
gcc p1.c 
gcc p1.c -o p1 (This is to specify the target file)
gcc p1.c -S p1.s
gcc -lm p1.c (The math libraries are loaded and linked properly)

Cohesion
SRP (high cohesion)
Type casting (conversion of a value of a specific DT into another type)
Down cast
Up cast
Implicit up cast/down cast
Explicit cast

int main()
{
    float num = 17 / 3;
    printf("Num = %d \n", num); // 5
    printf("Num = %f \n", num); // 5.66666
}
--------------------
&	Long logical operator (When operands are boolean)
&	Bitwise  operator	(When operands are numbers)
&	Unary address of operator (when operand is a variable)

C1 && C2 // short cut and
-----------------------------
Unary & "Address of" Operator
It can be applied only to a variable (including a pointer, because a pointer is a variable).
When we apply & to a variable, we get its address.

Unary * "Dereferencing" or "Value at" operator
It can be applied only to an address (including a pointer, because a pointer holds an address).
When we apply * to a variable, we get the value present in its address.

*num
value at(5.5)

*(&num)
= value at [ address of (num)]
= v at[1351]
= 5.5
= num

Address of operator
Value at operator
Pointer variable
Data type of an address

Day2:
Number is not an address
Address is not a number
AAdress (pointer) arithmetic
Types of Pointers
Pointer to a pointer

What is a DS
Array as a DS
Implentation of Array
Function call stack (how functions work implecitly)
Recursion and REcursive functions, base condition and problems
String
String handling functions
Dymanic Array (maaloc and free functions)
Structures
	what is strcuture
	data encapsulation
	strcuture definition
	padding
	pointer to a strcuture
	strcuture within a strcuture
	self referential strcuture


Arpita		3
Shobitha	2
Jaylakshmi	4
Prathiba	1
Janvi		1
UshaRahsmi	1


int num;  // %ld   %d
long int num;
signed long int num;
signed int num;
long num; // Error

long long int num; // 8 bytes   %lld
short int num; // 2 bytes   %d

DS
What is DS
Need and Birth of an Array
Abstraction (ease of use)

POINTER ARITHMETIC:
An arithmetic which involves an address
Address + number = Address
Address - number = Address
address - address = number

In a 1D Array, assume its name is arr
arr is address of 1st element

    //for (int i = 0; i < 10; i++)
    //for (int i = 0; i < n; i++)
    malloc(60) // always allocates 60 bytes
    ptr = malloc(sizeof(float) * size)
    void* malloc(size_t)

1. Find smallest anmd biggest elements of an Dy Array.
2. Swap consecutive elements of an Array
3. Remove duplicate elements of an array and store the remaining elements consecutively
4. In an Array of size N, partition the array in ratio X:Y such that elements in X[] are all greater than the P elements and all the elements in the Y[] are smaller than all the P elements. Print how many such P elements are there in the array.
---------------------------------------------
Pragna
char c1, c2, c3... c6;
Pass Pragna to a function as 6 Args.
Pragna is one data or 6 data?
1ts one data.

Its better to store one data in one var.
Thus we must excapsulate all characters of Pragna and store the 6 characters in a char array.

To know the end of the string we store the '\0' character.
Thus a string is a group characters which is one data.

char s1[10] = "gsss"; // 10 bytes
char s2[] = {'g', 's', 's', 's'}; // 4 bytes
char s3[] = "gsss"; // 5 bytes

char *p = s3;
p = s2; // pointer is not constant
p[0] = 'G'; // string is not constant
//*(p+0) = *p

const char *p1 = s3;
p1 = s2; // Error  Pointer is constant
p1[0] = 'G'; // Fine Bcoz string is not constant


char const* p2 = s3; //&s3[0]
p2 = s2; // Fine. Pointer is not constant
p2[0] = 'Y'; // Error. string is constant 


const char const *p3 = s3;
p3 = s2; // Error. Poiner is constant
p3[1] = 'X'; // Error. String is also constant

STRING HANDLING FUNCTIONS:
functions from the library string.h

strlen()

int i = 0;
for(; p[i] != '\0'; i++);
return i;

int strlen(char const*);

strcpy(D, S);
Ã§har* strcpy(char*, char const*);
strcmp(char const*, char const*);

strcat()
char* strrev(char*)

strrev() need the help of strlen()

strrev.h
strrev.c
strlen.h
strlen.c

str_demo.c  [ main() ]

---------------------------------------------
GOOD CODING PRACTICES:
1. Use indentation of 4 spaces.
2. Use space before and after every binary operators (except . -> )
3. Initialize all variables
4. A line break in between definitions of 2 functions.
5. While comparing a variable value with a literal (const value), place the literal on RHS.
    if(5 == num) Wrost
    if(num == 5) Better
6. 

AIDS Test1
https://forms.gle/JzCug3ETVDCeSutn6